<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title> Types - Easy Rust</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Chapter_0.html"><strong aria-hidden="true">1.</strong> Updates</a></li><li class="chapter-item expanded "><a href="Chapter_1.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="Chapter_2.html"><strong aria-hidden="true">3.</strong> Who am I?</a></li><li class="chapter-item expanded "><a href="Chapter_3.html"><strong aria-hidden="true">4.</strong> Catatan dari translator</a></li><li class="chapter-item expanded "><a href="Chapter_4.html"><strong aria-hidden="true">5.</strong> Writing Rust in Easy English</a></li><li class="chapter-item expanded "><a href="Chapter_5.html"><strong aria-hidden="true">6.</strong> Rust Playground</a></li><li class="chapter-item expanded "><a href="Chapter_6.html"><strong aria-hidden="true">7.</strong> ğŸš§ and âš ï¸</a></li><li class="chapter-item expanded "><a href="Chapter_7.html"><strong aria-hidden="true">8.</strong> Comments</a></li><li class="chapter-item expanded "><a href="Chapter_8.html" class="active"><strong aria-hidden="true">9.</strong> Types</a></li><li class="chapter-item expanded "><a href="Chapter_9.html"><strong aria-hidden="true">10.</strong> Type inference</a></li><li class="chapter-item expanded "><a href="Chapter_10.html"><strong aria-hidden="true">11.</strong> Printing 'hello, world!'</a></li><li class="chapter-item expanded "><a href="Chapter_11.html"><strong aria-hidden="true">12.</strong> Display and debug</a></li><li class="chapter-item expanded "><a href="Chapter_12.html"><strong aria-hidden="true">13.</strong> Mutability (changing)</a></li><li class="chapter-item expanded "><a href="Chapter_13.html"><strong aria-hidden="true">14.</strong> The stack, the heap, and pointers</a></li><li class="chapter-item expanded "><a href="Chapter_14.html"><strong aria-hidden="true">15.</strong> More about printing</a></li><li class="chapter-item expanded "><a href="Chapter_15.html"><strong aria-hidden="true">16.</strong> Strings</a></li><li class="chapter-item expanded "><a href="Chapter_16.html"><strong aria-hidden="true">17.</strong> const and static</a></li><li class="chapter-item expanded "><a href="Chapter_17.html"><strong aria-hidden="true">18.</strong> More on references</a></li><li class="chapter-item expanded "><a href="Chapter_18.html"><strong aria-hidden="true">19.</strong> Mutable references</a></li><li class="chapter-item expanded "><a href="Chapter_19.html"><strong aria-hidden="true">20.</strong> Giving references to functions</a></li><li class="chapter-item expanded "><a href="Chapter_20.html"><strong aria-hidden="true">21.</strong> Copy types</a></li><li class="chapter-item expanded "><a href="Chapter_21.html"><strong aria-hidden="true">22.</strong> Collection types</a></li><li class="chapter-item expanded "><a href="Chapter_22.html"><strong aria-hidden="true">23.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="Chapter_23.html"><strong aria-hidden="true">24.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="Chapter_24.html"><strong aria-hidden="true">25.</strong> Control flow</a></li><li class="chapter-item expanded "><a href="Chapter_25.html"><strong aria-hidden="true">26.</strong> Structs</a></li><li class="chapter-item expanded "><a href="Chapter_26.html"><strong aria-hidden="true">27.</strong> Enums</a></li><li class="chapter-item expanded "><a href="Chapter_27.html"><strong aria-hidden="true">28.</strong> Loops</a></li><li class="chapter-item expanded "><a href="Chapter_28.html"><strong aria-hidden="true">29.</strong> Implementing structs and enums</a></li><li class="chapter-item expanded "><a href="Chapter_29.html"><strong aria-hidden="true">30.</strong> Destructuring</a></li><li class="chapter-item expanded "><a href="Chapter_30.html"><strong aria-hidden="true">31.</strong> References and the dot operator</a></li><li class="chapter-item expanded "><a href="Chapter_31.html"><strong aria-hidden="true">32.</strong> Generics</a></li><li class="chapter-item expanded "><a href="Chapter_32.html"><strong aria-hidden="true">33.</strong> Option and Result</a></li><li class="chapter-item expanded "><a href="Chapter_33.html"><strong aria-hidden="true">34.</strong> Other collections</a></li><li class="chapter-item expanded "><a href="Chapter_34.html"><strong aria-hidden="true">35.</strong> The ? operator</a></li><li class="chapter-item expanded "><a href="Chapter_35.html"><strong aria-hidden="true">36.</strong> Traits</a></li><li class="chapter-item expanded "><a href="Chapter_36.html"><strong aria-hidden="true">37.</strong> Chaining methods</a></li><li class="chapter-item expanded "><a href="Chapter_37.html"><strong aria-hidden="true">38.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="Chapter_38.html"><strong aria-hidden="true">39.</strong> Closures</a></li><li class="chapter-item expanded "><a href="Chapter_39.html"><strong aria-hidden="true">40.</strong> The dbg! macro and .inspect</a></li><li class="chapter-item expanded "><a href="Chapter_40.html"><strong aria-hidden="true">41.</strong> Types of &amp;str</a></li><li class="chapter-item expanded "><a href="Chapter_41.html"><strong aria-hidden="true">42.</strong> Lifetimes</a></li><li class="chapter-item expanded "><a href="Chapter_42.html"><strong aria-hidden="true">43.</strong> Interior mutability</a></li><li class="chapter-item expanded "><a href="Chapter_43.html"><strong aria-hidden="true">44.</strong> Cow</a></li><li class="chapter-item expanded "><a href="Chapter_44.html"><strong aria-hidden="true">45.</strong> Type aliases</a></li><li class="chapter-item expanded "><a href="Chapter_45.html"><strong aria-hidden="true">46.</strong> The todo! macro</a></li><li class="chapter-item expanded "><a href="Chapter_46.html"><strong aria-hidden="true">47.</strong> Rc</a></li><li class="chapter-item expanded "><a href="Chapter_47.html"><strong aria-hidden="true">48.</strong> Multiple threads</a></li><li class="chapter-item expanded "><a href="Chapter_48.html"><strong aria-hidden="true">49.</strong> Closures in functions</a></li><li class="chapter-item expanded "><a href="Chapter_49.html"><strong aria-hidden="true">50.</strong> impl Trait</a></li><li class="chapter-item expanded "><a href="Chapter_50.html"><strong aria-hidden="true">51.</strong> Arc</a></li><li class="chapter-item expanded "><a href="Chapter_51.html"><strong aria-hidden="true">52.</strong> Channels</a></li><li class="chapter-item expanded "><a href="Chapter_52.html"><strong aria-hidden="true">53.</strong> Reading Rust documentation</a></li><li class="chapter-item expanded "><a href="Chapter_53.html"><strong aria-hidden="true">54.</strong> Attributes</a></li><li class="chapter-item expanded "><a href="Chapter_54.html"><strong aria-hidden="true">55.</strong> Box</a></li><li class="chapter-item expanded "><a href="Chapter_55.html"><strong aria-hidden="true">56.</strong> Box around traits</a></li><li class="chapter-item expanded "><a href="Chapter_56.html"><strong aria-hidden="true">57.</strong> Default and the builder pattern</a></li><li class="chapter-item expanded "><a href="Chapter_57.html"><strong aria-hidden="true">58.</strong> Deref and DerefMut</a></li><li class="chapter-item expanded "><a href="Chapter_58.html"><strong aria-hidden="true">59.</strong> Crates and modules</a></li><li class="chapter-item expanded "><a href="Chapter_59.html"><strong aria-hidden="true">60.</strong> Testing</a></li><li class="chapter-item expanded "><a href="Chapter_60.html"><strong aria-hidden="true">61.</strong> External crates</a></li><li class="chapter-item expanded "><a href="Chapter_61.html"><strong aria-hidden="true">62.</strong> A tour of the standard library</a></li><li class="chapter-item expanded "><a href="Chapter_62.html"><strong aria-hidden="true">63.</strong> Writing macros</a></li><li class="chapter-item expanded "><a href="Chapter_63.html"><strong aria-hidden="true">64.</strong> cargo</a></li><li class="chapter-item expanded "><a href="Chapter_64.html"><strong aria-hidden="true">65.</strong> Taking user input</a></li><li class="chapter-item expanded "><a href="Chapter_65.html"><strong aria-hidden="true">66.</strong> Using files</a></li><li class="chapter-item expanded "><a href="Chapter_66.html"><strong aria-hidden="true">67.</strong> cargo doc</a></li><li class="chapter-item expanded "><a href="Chapter_67.html"><strong aria-hidden="true">68.</strong> The end?</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Easy Rust</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="types"><a class="header" href="#types">Types</a></h2>
<p>Rust memiliki beberapa type, entah berupa angka, karakter, dsb. Beberapa type tersebut tergolong sederhana, sedangkan yang lainnya tergolong lebih rumit. Anda juga bisa membuat type Anda sendiri.</p>
<h3 id="primitive-types"><a class="header" href="#primitive-types">Primitive types</a></h3>
<p><strong><a href="https://youtu.be/OxTPU5UGMhs">See this chapter on YouTube</a></strong></p>
<p>Rust memiliki type sederhana yang biasanya disebut sebagai <strong>primitive types</strong> (primitive = paling dasar). Kita akan memulainya dengan integer dan <code>char</code> (karakter). Integer adalah semua angka yang tidak berkoma. Ada 2 type integer:</p>
<ul>
<li>Signed integers (Integer bertanda),</li>
<li>Unsigned integers (Integer tidak bertanda).</li>
</ul>
<p>Bertanda artinya <code>+</code> (tanda tambah) dan <code>-</code> (tanda minus), maka integer bertanda bisa jadi positif atau negatif (contohnya, +8, -8). Namun, integer tidak bertanda hanya dapat menyimpan bilangan bulat positif, karena ia tidak memiliki tanda.</p>
<p>Type-type integer bertanda adalah sebagai berikut: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, dan <code>isize</code>.
Sedangkan ini adalah type-type integer tidak bertanda: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, dan <code>usize</code>.</p>
<p>Angka setelah i ataupun u adalah panjang bit yang digunakan untuk menyimpan bilangan, jadi semakin besar angkanya, semakin banyak pula bit yang digunakan. 8 bit = 1 byte, jadi <code>i8</code> adalah 1 byte, <code>i64</code> adalah 8 byte, dan seterusnya. Type dengan panjang bit yang lebih lebar bisa menyimpan angka yang lebih besar. Contohnya, <code>u8</code> bisa menyimpan sampai dengan 255, sedangakan <code>u16</code> bisa menyimpan sampai dengan 65535. Juga <code>u128</code> bisa menyimpan sampai dengan 340282366920938463463374607431768211455.</p>
<p>Apa itu <code>isize</code> dan <code>usize</code>? Kedua type tersebut menandakan bahwa compiler akan mencocokkan ukuran bit dengan arsitektur komputer anda. (Jumlah bit pada komputer Anda biasanya disebut sebagai <strong>arsitektur</strong>.) Jadinya <code>isize</code> dan <code>usize</code> pada komputer 32-bit adalah <code>i32</code> dan <code>u32</code>, juga <code>isize</code> dan <code>usize</code> pada komputer 64-bit adalah <code>i64</code> dan <code>u64</code>.</p>
<p>Ada banyak alasan mengapa ada banyak sekali type dari integer. Salah satunya adalah performa: angka yang menggunakan byte yang kecil lebih cepat untuk diproses. Contohnya, angka -10 pada <code>i8</code> representasi binernya adalah <code>11110110</code>, namun pada <code>i128</code> representasi binernya adalah <code>11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110110</code>. Selain itu, ada juga beberapa kegunaan lainnya, seperti:</p>
<p>Karakter di Rust disebut sebagai <code>char</code>. Setiap <code>char</code> memiliki angka: huruf <code>A</code> memiliki nilai 65, sedangkan karakter <code>å‹</code> (&quot;kawan&quot; dalam Bahasa Mandarin) memiliki nilai 21451. Angka-angka ini disebut sebagai &quot;Unicode&quot;. Unicode yang menggunakan angka yang lebih kecil diperuntukkan bagi karakter yang sering digunakan, seperti A sampai Z, atau digit 0 sampai 9, maupun spasi.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let first_letter = 'A';
    let space = ' '; // Sebuah spasi di antara ' ' juga adalah sebuah char
    let other_language_char = 'á„'; // Berkat Unicode, bahasa lain seperti Cherokee juga tampil dengan baik
    let cat_face = 'ğŸ˜º'; // Emojis juga adalah char
}
</code></pre></pre>
<p>Karakter yang seringkali digunakan tersebut kebanyakan memiliki nilai dibawah dari 256. Maka, karakter-karakter tersebut muat jikalau disimpan didalam <code>u8</code>. Ingat, <code>u8</code> bisa menyimpan dari 0 sampai dengan 255, yang artinya, totalnya adalah 256. Ini berarti bahwa Rust bisa dengan aman melakukan <strong>cast</strong> dari <code>u8</code> ke <code>char</code>, menggunakan <code>as</code>. (&quot;Cast <code>u8</code> ke <code>char</code>&quot; artinya &quot;perlakukan <code>u8</code> sebagai <code>char</code>&quot;)</p>
<p>Melakukan Cast menggunakan <code>as</code> sangatlah berguna karena Rust benar-benar sangat ketat. Rust selalu perlu untuk mengetahui type yang digunakan dan tidak akan membiarkan kita menggunakan tipe data yang berbeda meskipun keduanya berupa integer. Pada contoh dibawah ini, code ini tidak akan berjalan:</p>
<pre><pre class="playground"><code class="language-rust">fn main() { // main() adalah dimana program Rust mulai berjalan. Sedangkan codenya dituliskan di dalam {} (curly brackets)

    let my_number = 100; // Kita tidak menuliskan type dari integer tersebut,
                         // sehingga Rust memilih i32. Rust selalu
                         // memilih i32 untuk integer apabila kita tidak
                         // memberitahukan compiler untuk menggunakan type yang berbeda.

    println!(&quot;{}&quot;, my_number as char); // âš ï¸
}
</code></pre></pre>
<p>Alasannya adalah sebagai berikut:</p>
<pre><code class="language-text">error[E0604]: only `u8` can be cast as `char`, not `i32`
 --&gt; src\main.rs:3:20
  |
3 |     println!(&quot;{}&quot;, my_number as char);
  |                    ^^^^^^^^^^^^^^^^^
</code></pre>
<p>Untungnya, kita bisa dengan mudah memperbaiki ini dengan menggunakan <code>as</code>. Kita tidak bisa melakukan cast  <code>i32</code> sebagai <code>char</code>, tapi kita bisa cast <code>i32</code> sebagai <code>u8</code>. Dan karena itu, kita bisa melakukan yang sama pada <code>u8</code> ke <code>char</code>. Maka kita menggunakan <code>as</code> untuk membuat my_number menjadi <code>u8</code>, dan di baris baru, kemudian mengubahnya lagi menjadi <code>char</code>. Jalankan code ini:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 100;
    println!(&quot;{}&quot;, my_number as u8 as char);
}
</code></pre></pre>
<p>Dan ia akan mencetak <code>d</code>, karena itu merupakan <code>char</code> yang bernilai 100.</p>
<p>Cara yang lebih mudah adalah, kita beri tahu saja ke Rust bahwa <code>my_number</code> itu adalah <code>u8</code>. Begini caranya:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number: u8 = 100; //  ubah my_number ke my_number: u8
    println!(&quot;{}&quot;, my_number as char);
}
</code></pre></pre>
<p>Itu merupakan 2 alasan mengapa ada banyak sekali type integer di Rust. Ini adalah alasan lainnya: <code>usize</code> adalah type yang digunakan Rust untuk keperluan <em>indexing</em>. (Indexing artinya &quot;yang mana item yang pertama&quot;, &quot;yang mana item yang kedua&quot;, dan seterusnya.) <code>usize</code> adalah type yang cocok untuk melakukan indexing, karena:</p>
<ul>
<li>Sebuah index tidak bisa negatif, jadi yang diperlukan adalah bilangan tidak bertanda (u)</li>
<li>Integer yang digunakan harus berukuran besar, karena terkadang kita perlu untuk meng-index banyak hal, tapi</li>
<li>u64 tidak bisa digunakan dikarenakan komputer 32-bit tidak bisa menggunakan u64.</li>
</ul>
<p>Jadi Rust menggunakan <code>usize</code> dan menyerahkan pada komputer kita untuk menentukan integer terbesar yang mampu dijangkau olehnya.</p>
<p>Mari kita pelajari lebih lanjut tentang <code>char</code>. Dapat dilihat bahwa <code>char</code> selalu berisi hanya 1 karakter, dan menggunakan <code>''</code>, bukan <code>&quot;&quot;</code>.</p>
<p>Semua <code>chars</code> menggunakan 4 byte memori, karena sejauh ini 4 bytes cukup untuk menampung hampir semua karakter apapun yang ada sekarang:</p>
<ul>
<li>Huruf-huruf dasar dan simbol biasanya memerlukan 1 dari 4 byte: <code>a b 1 2 + - = $ @</code></li>
<li>Aksara lainnya, seperti German Umlaut, memerlukan 2 dari 4 byte: <code>Ã¤ Ã¶ Ã¼ ÃŸ Ã¨ Ã© Ã  Ã±</code></li>
<li>Aksara Korea, Jepang atau Mandarin memerlukan 3 atau 4 byte: <code>å›½ ì•ˆ ë…•</code></li>
</ul>
<p>Di saat menggunakan karakter sebagai bagian dari sebuah string, maka string akan di-encode untuk menggunakan sesedikit mungkin memori yang dibutuhkan untuk setiap karakter.</p>
<p>Kita bisa menggunakan <code>.len()</code> untuk melihat ini:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Size of a char: {}&quot;, std::mem::size_of::&lt;char&gt;()); // 4 bytes
    println!(&quot;Size of string containing 'a': {}&quot;, &quot;a&quot;.len()); // .len() memberikan ukuran string dalam satuan byte
    println!(&quot;Size of string containing 'ÃŸ': {}&quot;, &quot;ÃŸ&quot;.len());
    println!(&quot;Size of string containing 'å›½': {}&quot;, &quot;å›½&quot;.len());
    println!(&quot;Size of string containing 'ğ“…±': {}&quot;, &quot;ğ“…±&quot;.len());
}
</code></pre></pre>
<p>Program ini akan mencetak:</p>
<pre><code class="language-text">Size of a char: 4
Size of string containing 'a': 1
Size of string containing 'ÃŸ': 2
Size of string containing 'å›½': 3
Size of string containing 'ğ“…±': 4
</code></pre>
<p>Anda bisa melihat bahwa huruf <code>a</code> memerlukan 1 byte, aksara Jerman <code>ÃŸ</code> memerlukan 2 byte, aksara Jepang <code>å›½</code> memerlukan 3 byte, dan aksara Mesir kuno <code>ğ“…±</code> memerlukan 4 byte.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let slice = &quot;Hello!&quot;;
    println!(&quot;Slice is {} bytes.&quot;, slice.len());
    let slice2 = &quot;ì•ˆë…•!&quot;; // Korean for &quot;hi&quot;
    println!(&quot;Slice2 is {} bytes.&quot;, slice2.len());
}
</code></pre></pre>
<p>Program ini akan mencetak:</p>
<pre><code class="language-text">Slice is 6 bytes.
Slice2 is 7 bytes.
</code></pre>
<p><code>slice</code> memiliki panjang 6 karakter dan memerlukan 6 byte, namun <code>slice2</code> memiliki panjang 3 karakter dan memerlukan 7 byte.</p>
<p>Jika <code>.len()</code> memberikan informasi tentang size dalam satuan byte, bagaimana tentang ukuran dalam satuan panjang karakter? Kita akan mempelajari tentang method ini nanti, tapi Anda bisa mengingat bahwa method <code>.chars().count()</code> bisa digunakan untuk keperluan tersebut. <code>.chars().count()</code> merubah apa yang kita tulis menjadi karakter dan menghitung berapa banyak karakter yang terdapat dalam tulisan tersebut.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let slice = &quot;Hello!&quot;;
    println!(&quot;Slice is {} bytes and also {} characters.&quot;, slice.len(), slice.chars().count());
    let slice2 = &quot;ì•ˆë…•!&quot;;
    println!(&quot;Slice2 is {} bytes but only {} characters.&quot;, slice2.len(), slice2.chars().count());
}
</code></pre></pre>
<p>Program ini akan mencetak:</p>
<pre><code class="language-text">Slice is 6 bytes and also 6 characters.
Slice2 is 7 bytes but only 3 characters.
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="Chapter_7.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="Chapter_9.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="Chapter_7.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="Chapter_9.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
